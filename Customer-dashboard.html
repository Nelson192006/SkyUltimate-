import React, { useEffect, useState, useRef } from "react";

// SkyUltimate - Single-file React dashboard (Customer + SuperAdmin demo) // Requirements addressed: // - Toast notifications (showToast) // - Theme toggle persisted to localStorage // - Profile edit (GET/PUT /api/user/profile) // - Order placement, price calculation (/api/orders/calculate-price) // - Manual payment modal & "I Have Paid" (/api/orders/submit-for-confirmation) // - WebSocket-driven real-time updates (order status, agent assignment) // - Live tracking with Google Maps (uses provided API KEY) // - Confirm pickup / confirm delivered buttons gated by 50m proximity // - SuperAdmin panel with Confirm Payment action (/api/orders/confirm-payment) // - Uses Tailwind classes for styling (expects Tailwind in project) // - Replace BACKEND_URL with your backend URL or set REACT_APP_BACKEND_URL in env

const BACKEND_URL = process.env.REACT_APP_BACKEND_URL || "https://skyultimate-backend-api-structure.onrender.com"; const WS_URL = (function(){ try{ return (BACKEND_URL.replace(/^http/, 'ws')) + '/ws'; }catch(e){return undefined} })(); const GOOGLE_API_KEY = process.env.REACT_APP_GOOGLE_MAPS_API_KEY || "AIzaSyAXZf0hfz_eiyAD5rnVEzmTgWmxIYmODiE"; // provided const LOGO_URL = "https://raw.githubusercontent.com/Nelson192006/SkyUltimate-/4e77ffc850e3621ae15902180075ad00958f4491/logo.png";

// Utility: Haversine distance (meters) function distanceMeters(lat1, lon1, lat2, lon2){ const R = 6371000; const toRad = (d) => d * Math.PI / 180; const dLat = toRad(lat2 - lat1); const dLon = toRad(lon2 - lon1); const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); return R * c; }

// Toast system let globalToastId = 0; function useToasts(){ const [toasts, setToasts] = useState([]); function showToast(message, type = 'info', ttl = 4000){ const id = ++globalToastId; setToasts(t => [...t, { id, message, type }]); setTimeout(()=> setToasts(t => t.filter(x => x.id !== id)), ttl); } function clearAll(){ setToasts([]); } return { toasts, showToast, clearAll }; }

export default function SkyUltimateDashboard(){ const [role, setRole] = useState(localStorage.getItem('role') || 'customer'); // toggle for demo: 'customer' | 'superadmin' const { toasts, showToast } = useToasts();

// Theme const [theme, setTheme] = useState(localStorage.getItem('theme') || 'light'); useEffect(()=>{ document.documentElement.setAttribute('data-theme', theme); localStorage.setItem('theme', theme); }, [theme]);

// Profile const [profile, setProfile] = useState({ name:'', email:'', phone:'' }); useEffect(()=>{ fetchProfile(); }, []); async function fetchProfile(){ try{ const res = await fetch(${BACKEND_URL}/api/user/profile, { credentials: 'include' }); if(!res.ok) return; const data = await res.json(); setProfile(data); }catch(e){ console.warn('profile fetch failed', e); } } async function saveProfile(){ try{ const res = await fetch(${BACKEND_URL}/api/user/profile, { method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify(profile), credentials:'include' }); if(!res.ok) throw new Error('failed'); showToast('Profile updated successfully!', 'success'); }catch(e){ showToast('Could not save profile','error'); } }

// Order form const [orderForm, setOrderForm] = useState({ pickup:'', pickupLat:null, pickupLng:null, dropoff:'', dropoffLat:null, dropoffLng:null, weight:1, description:'', service:'standard' }); const [calculatedPrice, setCalculatedPrice] = useState(null); const [currentOrder, setCurrentOrder] = useState(null);

// Payment modal const [paymentModalOpen, setPaymentModalOpen] = useState(false); const bankInfo = [ { bank: 'Moniepoint', account: '0123456789', name: 'SkyUltimate' }, { bank: 'UBA', account: '0987654321', name: 'SkyUltimate' }, { bank: 'GTBank', account: '1122334455', name: 'SkyUltimate' } ];

// WebSocket / Real-time const wsRef = useRef(null); useEffect(()=>{ if(!WS_URL) return; try{ const ws = new WebSocket(WS_URL); wsRef.current = ws; ws.onopen = ()=> console.log('ws open'); ws.onmessage = (ev)=>{ try{ const msg = JSON.parse(ev.data); handleRealtime(msg); }catch(e){ console.log('ws msg', ev.data); } } ws.onclose = ()=> console.log('ws closed'); return ()=> ws.close(); }catch(e){ console.warn('WebSocket failed', e); } }, []);

function handleRealtime(msg){ // expected shapes: {type:'order_update', order}, {type:'agent_location', orderId, agent} if(msg.type === 'order_update'){ const order = msg.order; if(currentOrder && order.id === currentOrder.id){ setCurrentOrder(order); } if(order.status === 'assigned' && order.id === currentOrder?.id){ showToast('An agent has been assigned to your order.', 'info'); } if(order.status === 'payment_confirmed' && role === 'customer' && order.customerId === profile.id){ showToast('Payment confirmed! Your order is now live tracking.', 'success'); } } if(msg.type === 'agent_location'){ const agent = msg.agent; const orderId = msg.orderId; if(currentOrder && orderId === currentOrder.id){ setCurrentOrder(o => ({ ...o, agent })); } } }

// Price calculation async function calculatePrice(){ try{ const payload = { pickup: orderForm.pickup, dropoff: orderForm.dropoff, weight: orderForm.weight, service: orderForm.service }; const res = await fetch(${BACKEND_URL}/api/orders/calculate-price, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload), credentials:'include' }); if(!res.ok) throw new Error('calc failed'); const data = await res.json(); setCalculatedPrice(data.price); showToast('Price calculated', 'info'); }catch(e){ showToast('Failed to calculate price', 'error'); } }

// Submit for confirmation (I have paid) async function submitForConfirmation(){ try{ const payload = { ...orderForm, price: calculatedPrice }; const res = await fetch(${BACKEND_URL}/api/orders/submit-for-confirmation, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload), credentials:'include' }); if(!res.ok) throw new Error('submit failed'); const data = await res.json(); setCurrentOrder(data.order); setPaymentModalOpen(false); showToast('Order submitted! Your payment is being verified by an Admin.', 'success'); }catch(e){ showToast('Failed to submit order', 'error'); } }

// SuperAdmin: confirm payment async function confirmPayment(orderId){ try{ const res = await fetch(${BACKEND_URL}/api/orders/confirm-payment, { method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ orderId }), credentials:'include' }); if(!res.ok) throw new Error('confirm failed'); const data = await res.json(); showToast('Payment confirmed and agents notified.', 'success'); }catch(e){ showToast('Could not confirm payment', 'error'); } }

// Confirm pickup / delivery (agent-side triggers are POST to endpoints) async function confirmPickedUp(){ if(!currentOrder) return; try{ const res = await fetch(${BACKEND_URL}/api/orders/${currentOrder.id}/confirm-pickup, { method:'POST', credentials:'include' }); if(!res.ok) throw new Error('fail'); showToast('Pickup confirmed', 'success'); }catch(e){ showToast('Could not confirm pickup', 'error'); } } async function confirmDelivered(){ if(!currentOrder) return; try{ const res = await fetch(${BACKEND_URL}/api/orders/${currentOrder.id}/confirm-delivery, { method:'POST', credentials:'include' }); if(!res.ok) throw new Error('fail'); showToast('Delivery confirmed', 'success'); }catch(e){ showToast('Could not confirm delivery', 'error'); } }

// Map handling (Google Maps) const mapRef = useRef(null); const mapInstance = useRef(null); const markersRef = useRef({ pickup: null, dropoff: null, agent: null, route: null }); useEffect(()=>{ if(!GOOGLE_API_KEY) return; if(window.google && window.google.maps){ initMap(); return; } const script = document.createElement('script'); script.src = https://maps.googleapis.com/maps/api/js?key=${GOOGLE_API_KEY}&libraries=places; script.async = true; script.defer = true; script.onload = () => initMap(); document.head.appendChild(script); return ()=>{ document.head.removeChild(script); }; }, []);

function initMap(){ if(!mapRef.current) return; mapInstance.current = new window.google.maps.Map(mapRef.current, { center:{ lat:6.5244, lng:3.3792 }, zoom:12 }); } useEffect(()=>{ if(!mapInstance.current) return; // update pickup/dropoff markers const m = mapInstance.current; const { pickupLat, pickupLng, dropoffLat, dropoffLng } = orderForm; if(pickupLat && pickupLng){ if(!markersRef.current.pickup) markersRef.current.pickup = new window.google.maps.Marker({ map:m, title: 'Pickup' }); markersRef.current.pickup.setPosition({ lat: pickupLat, lng: pickupLng }); } if(dropoffLat && dropoffLng){ if(!markersRef.current.dropoff) markersRef.current.dropoff = new window.google.maps.Marker({ map:m, title: 'Dropoff' }); markersRef.current.dropoff.setPosition({ lat: dropoffLat, lng: dropoffLng }); } if(currentOrder?.agent && currentOrder.agent.lat && currentOrder.agent.lng){ if(!markersRef.current.agent) markersRef.current.agent = new window.google.maps.Marker({ map:m, title: 'Agent', icon: { path: window.google.maps.SymbolPath.CIRCLE, scale:8 } }); markersRef.current.agent.setPosition({ lat: currentOrder.agent.lat, lng: currentOrder.agent.lng }); } }, [orderForm.pickupLat, orderForm.pickupLng, orderForm.dropoffLat, orderForm.dropoffLng, currentOrder?.agent]);

// Geocoding helpers (Places Autocomplete could be added, but simple geocode via maps Geocoder) async function geocodeAddress(address, target){ if(!window.google || !window.google.maps) return; const geocoder = new window.google.maps.Geocoder(); return new Promise((resolve, reject)=>{ geocoder.geocode({ address }, (results, status)=>{ if(status === 'OK' && results[0]){ const loc = results[0].geometry.location; setOrderForm(f => ({ ...f, [target+'Lat']: loc.lat(), [target+'Lng']: loc.lng() })); resolve(loc); }else reject(status); }); }); }

// Helper: compute if agent within 50m of pickup/dropoff function canConfirmPickup(){ if(!currentOrder?.agent || !orderForm.pickupLat) return false; const d = distanceMeters(orderForm.pickupLat, orderForm.pickupLng, currentOrder.agent.lat, currentOrder.agent.lng); return d <= 50; } function canConfirmDelivered(){ if(!currentOrder?.agent || !orderForm.dropoffLat) return false; const d = distanceMeters(orderForm.dropoffLat, orderForm.dropoffLng, currentOrder.agent.lat, currentOrder.agent.lng); return d <= 50; }

// Simple UI layout return ( <div className="min-h-screen bg-gray-50" > <div className="max-w-6xl mx-auto p-4"> <header className="flex items-center justify-between"> <div className="flex items-center gap-3"> <img src={LOGO_URL} alt="logo" className="w-12 h-12 rounded-full"/> <h1 className="text-2xl font-bold">SkyUltimate — Dashboard</h1> </div> <div className="flex items-center gap-2"> <select value={role} onChange={(e)=>{ setRole(e.target.value); localStorage.setItem('role', e.target.value); }} className="px-3 py-2 border rounded"> <option value="customer">Customer</option> <option value="superadmin">Super Admin</option> </select> <button onClick={()=> setTheme(t => t === 'light' ? 'dark' : 'light')} className="px-3 py-2 border rounded">Theme: {theme}</button> </div> </header>

<main className="mt-6 grid grid-cols-1 md:grid-cols-3 gap-4">
      <section className="col-span-1 md:col-span-2 bg-white p-4 rounded shadow">
        {role === 'customer' ? (
          <>
            <h2 className="text-xl font-semibold mb-2">Place a New Order</h2>
            <div className="space-y-2">
              <label className="block">Pickup address</label>
              <input value={orderForm.pickup} onChange={(e)=> setOrderForm(f => ({ ...f, pickup: e.target.value }))} className="w-full border p-2 rounded" placeholder="Pickup address" />
              <div className="flex gap-2">
                <button className="px-3 py-2 border rounded" onClick={async ()=>{ try{ await geocodeAddress(orderForm.pickup, 'pickup'); showToast('Pickup located on map','info'); }catch(e){ showToast('Could not geocode pickup','error'); } }}>Locate Pickup</button>
                <button className="px-3 py-2 border rounded" onClick={()=>{ navigator.geolocation.getCurrentPosition(pos => { setOrderForm(f=>({...f, pickupLat: pos.coords.latitude, pickupLng: pos.coords.longitude, pickup: 'Current location'})); showToast('Using your current location for pickup', 'info'); }, ()=> showToast('Could not get location','error')); }}>Use My Location</button>
              </div>

              <label className="block">Dropoff address</label>
              <input value={orderForm.dropoff} onChange={(e)=> setOrderForm(f => ({ ...f, dropoff: e.target.value }))} className="w-full border p-2 rounded" placeholder="Drop-off address" />
              <div className="flex gap-2">
                <button className="px-3 py-2 border rounded" onClick={async ()=>{ try{ await geocodeAddress(orderForm.dropoff, 'dropoff'); showToast('Dropoff located on map','info'); }catch(e){ showToast('Could not geocode dropoff','error'); } }}>Locate Dropoff</button>
              </div>

              <label className="block">Weight (kg)</label>
              <input type="number" value={orderForm.weight} onChange={(e)=> setOrderForm(f=>({...f, weight: Number(e.target.value)}))} className="w-32 border p-2 rounded" />

              <label className="block">Service type</label>
              <select value={orderForm.service} onChange={(e)=> setOrderForm(f=>({...f, service: e.target.value}))} className="border p-2 rounded">
                <option value="standard">Standard</option>
                <option value="express">Express</option>
                <option value="priority">Priority</option>
              </select>

              <label className="block">Description</label>
              <textarea value={orderForm.description} onChange={(e)=> setOrderForm(f=>({...f, description: e.target.value}))} className="w-full border p-2 rounded" rows={3}></textarea>

              <div className="flex gap-2 mt-3">
                <button onClick={calculatePrice} className="px-4 py-2 bg-red-600 text-white rounded">Calculate Price</button>
                {calculatedPrice !== null && (
                  <div className="px-4 py-2 border rounded flex items-center gap-3">Price: <strong>₦{calculatedPrice}</strong>
                    <button onClick={()=> setPaymentModalOpen(true)} className="ml-4 px-3 py-1 border rounded">Proceed to Payment</button>
                  </div>
                )}
              </div>
            </div>

            <div className="mt-6 h-96" ref={mapRef} />

            {/* Live tracking / order status */}
            {currentOrder && (
              <div className="mt-4 bg-gray-50 p-4 rounded">
                <h3 className="font-semibold">Order Status: {currentOrder.status}</h3>
                <div>Order ID: {currentOrder.id}</div>
                <div>Price: ₦{currentOrder.price}</div>
                {currentOrder.agent && <div>Agent: {currentOrder.agent.name} — {currentOrder.agent.phone}</div>}

                <div className="mt-3 flex gap-2">
                  <button disabled={!canConfirmPickup()} onClick={confirmPickedUp} className={`px-3 py-2 rounded ${canConfirmPickup() ? 'bg-green-600 text-white' : 'bg-gray-200'}`}>Confirm Item Picked Up</button>
                  <button disabled={!canConfirmDelivered()} onClick={confirmDelivered} className={`px-3 py-2 rounded ${canConfirmDelivered() ? 'bg-blue-600 text-white' : 'bg-gray-200'}`}>Confirm Order Delivered</button>
                </div>
              </div>
            )}

          </>
        ) : (
          // SuperAdmin panel (simplified)
          <div>
            <h2 className="text-xl font-semibold mb-2">Super Admin — Payment Queue</h2>
            <p className="mb-2">This view shows orders awaiting payment confirmation. Click <strong>Confirm Payment</strong> to confirm and notify agents.</p>
            <SuperAdminQueue showToast={showToast} confirmPayment={confirmPayment} backend={BACKEND_URL} />
          </div>
        )}
      </section>

      <aside className="bg-white p-4 rounded shadow">
        <h3 className="font-semibold">Settings & Profile</h3>
        <div className="mt-2">
          <label className="block">Name</label>
          <input value={profile.name || ''} onChange={(e)=> setProfile(p=>({...p, name: e.target.value}))} className="w-full border p-2 rounded" />
          <label className="block mt-2">Email</label>
          <input value={profile.email || ''} onChange={(e)=> setProfile(p=>({...p, email: e.target.value}))} className="w-full border p-2 rounded" />
          <label className="block mt-2">Phone</label>
          <input value={profile.phone || ''} onChange={(e)=> setProfile(p=>({...p, phone: e.target.value}))} className="w-full border p-2 rounded" />
          <div className="flex gap-2 mt-3">
            <button onClick={saveProfile} className="px-3 py-2 bg-red-600 text-white rounded">Save Changes</button>
          </div>

          <div className="mt-4">
            <h4 className="font-semibold">Service Analytics</h4>
            <div className="text-sm mt-2">Total orders this month: <strong>—</strong></div>
            <div className="text-sm">Average order cost: <strong>—</strong></div>
            <div className="text-sm">Most used pickup location: <strong>—</strong></div>
          </div>

          <div className="mt-4">
            <h4 className="font-semibold">Help & Support</h4>
            <div className="flex gap-2 mt-2">
              <a href="tel:+234000000000" className="px-3 py-2 border rounded">Call Dedicated Support</a>
              <button className="px-3 py-2 border rounded" onClick={()=> showToast('Live chat opened (demo)', 'info')}>Live Chat</button>
            </div>
          </div>

        </div>
      </aside>
    </main>

    {/* Payment Modal */}
    {paymentModalOpen && (
      <div className="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center">
        <div className="bg-white p-4 rounded w-full max-w-lg">
          <div className="flex justify-between items-center">
            <h3 className="font-semibold">Manual Payment — Bank Details</h3>
            <button onClick={()=> setPaymentModalOpen(false)} className="px-2 py-1">Close</button>
          </div>
          <div className="mt-3">
            <p>Pay the exact amount to any of these accounts. After payment, return and click "I Have Paid".</p>
            <ul className="mt-2 space-y-2">
              {bankInfo.map(b => (
                <li key={b.account} className="flex justify-between items-center border p-2 rounded">
                  <div>
                    <div className="font-semibold">{b.bank}</div>
                    <div>{b.account} — {b.name}</div>
                  </div>
                  <div className="flex gap-2">
                    <button onClick={()=>{ navigator.clipboard.writeText(b.account); showToast('Account copied to clipboard', 'info'); }} className="px-3 py-1 border rounded">Copy</button>
                  </div>
                </li>
              ))}
            </ul>
            <div className="mt-3 flex gap-2">
              <button onClick={submitForConfirmation} className="px-3 py-2 bg-green-600 text-white rounded">I Have Paid</button>
              <button onClick={()=> setPaymentModalOpen(false)} className="px-3 py-2 border rounded">Cancel</button>
            </div>
          </div>
        </div>
      </div>
    )}

    {/* Toasts */}
    <div className="fixed right-4 bottom-4 flex flex-col gap-2 z-50">
      {toasts.map(t => (
        <div key={t.id} className={`px-4 py-2 rounded shadow ${t.type === 'success' ? 'bg-green-100 border-green-400' : t.type === 'error' ? 'bg-red-100 border-red-400' : 'bg-blue-100 border-blue-400'}`}>
          {t.message}
        </div>
      ))}
    </div>

  </div>
</div>

); }
function SuperAdminQueue({ showToast, confirmPayment, backend }){
  const [orders, setOrders] = useState([]);
  useEffect(()=>{ fetchQueue(); }, []);
  async function fetchQueue(){
    try{
      const res = await fetch(`${backend}/api/orders/pending-payments`, { credentials:'include' });
      if(!res.ok) throw new Error('no'); const data = await res.json(); setOrders(data.orders || []);
    }catch(e){ showToast('Could not load queue','error'); }
  }
  return (
    <div className="space-y-3">
      {orders.length === 0 && <div>No pending payments right now.</div>}
      {orders.map(o => (
        <div key={o.id} className="border p-3 rounded flex justify-between items-start">
          <div>
            <div className="font-semibold">Order {o.id}</div>
            <div>Customer: {o.customerName || o.customerId}</div>
            <div>Amount: ₦{o.price}</div>
            <div>Status: {o.status}</div>
          </div>
          <div className="flex flex-col gap-2">
            <button onClick={()=> confirmPayment(o.id)} className="px-3 py-2 bg-green-600 text-white rounded">Confirm Payment</button>
            <button onClick={()=> navigator.clipboard.writeText(JSON.stringify(o))} className="px-3 py-2 border rounded">Copy Details</button>
          </div>
        </div>
      ))}
    </div>
  );
}
